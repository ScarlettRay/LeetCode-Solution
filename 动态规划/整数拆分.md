题目：


给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

例如，给定 n = 2，返回1（2 = 1 + 1）；给定 n = 10，返回36（10 = 3 + 3 + 4）。

注意：你可以假设 n 不小于2且不大于58。



分析：

这个问题实际是一个动态规划问题。我们所要避免的是在和中尽可能少的出现1，所以

设n = x1 + x2 + x3 + ... + xi + ... + xn，那么乘积为x1 * x2 * x3 * ... xi * ...xn，若xi >=5，则xi = （xi - 3）+ 3 , 等式两边的乘积分别为xi 和 3（xi - 3） = 3xi - 9 。若要使 3xi - 9 < xi , 则要xi < 4.5，与xi >=5矛盾，所以xi >= 5，乘积最大不成立。

当n = 3 时，返回2（3 = 2 + 1）;

当 n = 4 时，则可以拆分成 2 x 2 = 4 >3 x 1；

当n = 5 时，我们需要尽可能的避免和中出现1，所以 返回6（5 = 2 + 3）；

当n = 6 时，可以拆分成2 + 2 + 2 和 3 + 3两种情况，很容易就可以知道2 x 2 x 2 = 8< 3 x 3 = 9。

所以我们可以得出当正整数n除以3得k余数为1时，我们需要将其转化为k - 1余数为4，当余数为0或2时保持不变，这样得到的正整数的和的乘积即为最大乘积。下面是Java代码：
```
class Solution {
    public int integerBreak(int n) {
        if(n < 4){
            return n - 1;
        }
        int count3 = 0;
        if(n % 3 == 0){
            return (int)Math.pow(3,n/3);
        }else if(n % 3 == 1){
            return (int)Math.pow(3,(n/3 - 1)) * 4;
        }else{
            return (int)Math.pow(3, n/3) * 2;
        }
    }
}
```